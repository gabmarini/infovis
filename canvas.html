<!DOCTYPE html>
<html lang="en" style="width: 100%; height: 100%">

<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="snowflakes.css" rel="stylesheet">
    <script src="http://d3js.org/d3.v3.min.js"></script>
</head>

<body>
    <script>
        var w = 900,
            h = 500

        var svg = d3.select('body').append('svg:svg')
            .attr('width', w)
            .attr('height', h);

        var snowflake

        d3.xml("snowflake.svg",
            function(error, documentFragment) {

                if (error) {
                    console.log(error);
                    return;
                }
                var svgNode = documentFragment
                    .getElementsByTagName("svg")[0].getElementsByTagName('g')[0].getElementsByTagName('path')[0];
                //use plain Javascript to extract the node

                //svg.node().appendChild(svgNode);
                //d3's selection.node() returns the DOM node, so we
                //can use plain Javascript to append content

                snowflake = d3.select(svgNode).attr('d')

            });
        var borderbox = svg.append('rect').classed('border-box', true)
            .attr({
                width: w,
                height: h
            });

        setInterval(function() {
            var flakes = spawn3RandomFlakes()
            var renderedFlakes = appendToCanvas(flakes)

            transition()

        }, 1000)

        function transition() {

            d3.selectAll('.moving')
                .filter(function(d) {
                    return d3.select(this).attr('T') == 1
                })
                .attr('T', 0)
                .transition()
                .ease('linear')
                .duration(1000)
                .attr('T', 1)
                .attr('transform', function(d) {
                    if (d.y != h - d.radius * 2) {
                        var mov = (Math.random() * (d.x + 100 - d.x + 100)) + (d.x - 100)
                        d.x = Math.max(0, Math.min(w - 2 * d.radius, mov))
                    }
                    var fall = d.y + d.fall
                    if (fall >= h - d.radius * 2) {
                        fall = h - d.radius * 2
                        d.y = fall
                        d3.select(this)
                            .classed('near-end', true)
                            .classed('moving', false)
                    } else {
                        d.y = fall
                    }
                    return "translate(" + d.x + "," + d.y + ") " + "scale(" + (d.radius * 2 / 35) + "," + (d.radius *
                        2 / 35) + ")"
                })
                .attr('cx', function(d) {
                    return d.x
                })
                .attr('cy', function(d) {
                    return d.y
                })
                .attr('r', function(d) {
                    return d.radius
                })
                .tween('attr', checkCollision())
                .each('end', function(d) {
                    d3.selectAll('.near-end')
                        .filter(function(d) {
                            return d3.select(this).attr('T') == 1
                        })
                        .classed('near-end', false)
                        .classed('ended', true)
                    transition();
                })
                /*

                d3.selectAll('.moving')
                    .filter(function (d) {
                        return d3.select(this).attr('T') == 1
                    })
                    .attr('T', 0)
                    .transition()
                    .ease('linear')
                    .duration(1000)
                    .attr('T', 1)
                    .attr('cx', function (d) {
                        if (+d3.select(this).attr('cy') != h - d.radius) {
                            var mov = (Math.random() * (d.x + 100 - d.x + 100)) + (d.x - 100)
                            d.x = Math.max(d.radius, Math.min(w - d.radius, mov))
                        }
                        return d.x

                    })
                    .attr('cy', function (d) {
                        var fall = d.y + d.fall
                        if (fall > h) {
                            fall = h - d.radius
                            d3.select(this)
                                .classed('near-end', true)
                                .classed('moving', false)
                        }
                        return d.y = fall
                        /*
                        var fall = d.y + Math.random() * 200
                        if (fall > h) {
                            fall = h - d.radius
                            d3.select(this)
                                .classed('near-end', true)
                                .classed('moving', false)
                        }
                        return d.y = fall*/
                /*
                                })
                                .tween("attr", checkCollision())
                                .each("end", function (d) {
                                    d3.selectAll('.near-end')
                                        .filter(function (d) {
                                            return d3.select(this).attr('T') == 1
                                        })
                                        .classed('near-end', false)
                                        .classed('ended', true)
                                    transition();
                                })

                            d3.selectAll('.ended')
                                .filter(function (d) {
                                    return d3.select(this).attr('T') == 1
                                })
                                .transition()
                                .duration(1000)
                                .tween('attr', checkCollision())
                */
        }


        function checkCollision() {
            return function(d, i, a) {
                return function(t) {
                    if (collide(this)) {} else {
                        //d3.select(this).style('fill', 'black')
                    }
                }
            }
        }


        function collide(node) {
            var nodeID = +d3.select(node).attr('id')
            var dx = +d3.select(node).attr('cx')
            var dy = +d3.select(node).attr('cy')
            var r = +d3.select(node).attr('r'),
                nx1 = dx - r,
                nx2 = dx + r,
                ny1 = dy - r,
                ny2 = dy + r;
            var colliding = false;
            d3.selectAll('g').each(function(point, i) {
                var pointID = +d3.select(this).attr('id')
                var pr = +d3.select(this).attr('r')
                var px = +d3.select(this).attr('cx')
                var py = +d3.select(this).attr('cy')
                var x1 = px - pr,
                    y1 = py - pr,
                    x2 = px + pr,
                    y2 = py + pr;
                var x = dx - px,
                    y = dy - py,
                    l = Math.sqrt(x * x + y * y),
                    rad = r + pr
                if (l < rad) {
                    l = (l - rad) / l * .5

                    if (!isFinite(l)) {
                        l = 0
                    }
                    x *= l
                    y *= l
                    dx -= x
                    dy -= y
                    px += x
                    py += y

                    if (d3.select(this).classed('ended') && d3.select(this).attr('T') == 1) {
                        d3.select(node).attr('cx', Math.max(r, Math.min(w - r, dx)))
                        d3.select(this).attr('cx', Math.max(pr, Math.min(w - pr, px)))

                    } else if (d3.select(node).classed('ended') && d3.select(node).attr('T') == 1) {
                        d3.select(node).attr('cx', Math.max(r, Math.min(w - r, dx)))
                        d3.select(this).attr('cx', Math.max(pr, Math.min(w - pr, px)))
                    } else {
                        d3.select(node).attr('cx', Math.max(r, Math.min(w - r, dx)))
                        d3.select(node).attr('cy', Math.max(r, Math.min(h - r, dy)))
                        d3.select(this).attr('cx', Math.max(pr, Math.min(w - pr, px)))
                        d3.select(this).attr('cy', Math.max(py, Math.min(h - pr, py)))
                    }



                }
                if (!(nx1 > x2 || nx2 < x1 || ny1 > y2 || ny2 < y1) && pointID != nodeID)
                    colliding = true
            })
            return colliding
        }

        function appendToCanvas(flakes) {

            var g = svg.selectAll()
                .data(flakes)
                .enter()
                .append('g')
                .classed('new snowflake', true)
                .style('fill-opacity', function(d) {
                    return Math.random()
                })
                .attr('T', 0)
                .attr('transform', function(d) {
                    var y = d.y = d.y - d.radius * 2
                    return "translate(" + d.x + "," + y + ") " + "scale(" + (d.radius * 2 / 35) + "," + (d.radius *
                        2 / 35) + ") "
                })
                .attr('cx', function(d) {
                    return d.x
                })
                .attr('cy', function(d) {
                    return d.y
                })
                .attr('r', function(d) {
                    return d.radius
                })
                .attr('id', function(d) {
                    return d.id
                })

            g.append('path')
                .attr('d', snowflake)

            g.transition()
                .ease('linear')
                .duration(1000)
                .attr('T', 1)
                .attr('transform', function(d) {
                    if (d.y != h - d.radius) {
                        var mov = (Math.random() * (d.x + 50 - d.x + 50)) + (d.x - 50)
                        d.x = Math.max(2 * d.radius, Math.min(w - 2 * d.radius, mov))
                    }
                    d.y = d.y + d.fall
                    return "translate(" + d.x + "," + d.y + ") " + "scale(" + (d.radius * 2 / 35) + "," + (d.radius *
                        2 / 35) + ") "
                })
                .each("end", function(d) {
                    if (!d3.select(this).classed('near-end')) {
                        d3.select(this).classed('moving', true)
                    }
                    d3.select(this).classed('new', false)
                    transition()
                })

            /*

            return svg.selectAll()
                .data(flakes)
                .enter()
                .append("svg:circle")
                .classed('new', true)
                .attr('T', 0)
                .attr('r', function (d) {
                    return d.radius
                })
                .attr('cx', function (d) {
                    return d.x
                })
                .attr('cy', function (d) {
                    return d.y
                }).attr('id', function (d) {
                    return d.id
                })
                .transition()
                .ease("linear")
                .duration(1000)
                .attr('T', 1)
                .attr('cx', function (d) {
                    if (+d3.select(this).attr('cy') != h - d.radius) {
                        var mov = (Math.random() * (d.x + 50 - d.x + 50)) + (d.x - 50)
                        d.x = Math.max(d.radius, Math.min(w - d.radius, mov))
                    }
                    return d.x
                })
                .attr('cy', function (d) {
                    return d.y = d.y + d.fall
                    /*
                    var fall = d.y + Math.random() * 200
                    if (fall > h) {
                        fall = h - d.radius
                        d3.select(this)
                            .classed('near-end', true)
                            .classed('moving', false)
                    }
                    return d.y = fall*/
            /*
                          })
                          .tween("attr", checkCollision())
                          .each("end", function (d) {
                              if (!d3.select(this).classed('near-end')) {
                                  d3.select(this).classed('moving', true)
                              }
                              d3.select(this).classed('new', false)
                              transition()
                          })*/

        }

        function spawn3RandomFlakes() {
            return d3.range(3).map(function() {
                var r = Math.random() * (30 - 7) + 7
                var numfall = Math.random() * (15 - 5) + 5
                var fallingY = h / numfall
                var rot = Math.floor(Math.random() * (20 - 10) + 10)
                return {
                    radius: r,
                    x: Math.random() * w - r * 2,
                    y: -r,
                    id: Math.random(),
                    fall: fallingY,
                    rot: rot
                }
            })
        }
    </script>
</body>


</html>