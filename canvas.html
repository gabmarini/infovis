<!DOCTYPE html>
<html lang="en" style="width: 100%; height: 100%">

<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="snowflakes.css" rel="stylesheet">
    <script src="http://d3js.org/d3.v3.min.js"></script>
</head>

<body>
    <script>
        var w = 960,
            h = 500

        var svg = d3.select('body').append('svg:svg')
            .attr('width', w)
            .attr('height', h);

        var borderbox = svg.append('rect').classed('border-box', true)
            .attr({
                width: w,
                height: h
            });

        var counter = 0
        setInterval(function() {
            //if (counter == 0) {
            var flakes = spawn3RandomFlakes()
            var renderedFlakes = appendToCanvas(flakes)
                //counter++
                //}

            if (counter == 0) {
                transition()
                counter++
            }


        }, 1000)

        function transition() {

            d3.selectAll('.moving')
                .filter(function(d) {
                    return d3.select(this).attr('T') == 1
                })
                .attr('T', 0)
                .transition()
                .ease('linear')
                .duration(1000)
                .attr('T', 1)
                .attr('cx', function(d) {
                    if (+d3.select(this).attr('cy') != h - d.radius) {
                        var mov = (Math.random() * (d.x + 100 - d.x + 100)) + (d.x - 100)
                        d.x = Math.max(d.radius, Math.min(w - d.radius, mov))
                    }
                    return d.x

                })
                .attr('cy', function(d) {
                    var fall = d.y + Math.random() * 200
                    if (fall > h) {
                        console.log(fall)
                        debugger
                        fall = h - d.radius
                        d3.select(this)
                            .classed('near-end', true)
                            .classed('moving', false)
                    }
                    return d.y = fall
                })
                .tween("attr", checkCollision())
                .each("end", function(d) {
                    d3.selectAll('.near-end')
                        .classed('near-end', false)
                        .classed('ended', true)
                    transition();
                })

            d3.selectAll('.ended')
                .filter(function(d) {
                    return d3.select(this).attr('T') == 1
                })
                .transition()
                .duration(100)
                .tween('attr', checkCollision())

        }


        function checkCollision() {
            return function(d, i, a) {
                return function(t) {
                    if (collide(this)) {
                        d3.select(this).style('fill', 'red')
                    } else {
                        d3.select(this).style('fill', 'black')
                    }
                }
            }
        }


        function collide(node) {
            var nodeID = +d3.select(node).attr('id')
            var dx = +d3.select(node).attr('cx')
            var dy = +d3.select(node).attr('cy')
            var r = +d3.select(node).attr('r'),
                nx1 = dx - r,
                nx2 = dx + r,
                ny1 = dy - r,
                ny2 = dy + r;
            var colliding = false;
            d3.selectAll('circle').each(function(point, i) {
                var pointID = +d3.select(this).attr('id')
                var pr = +d3.select(this).attr('r')
                var px = +d3.select(this).attr('cx')
                var py = +d3.select(this).attr('cy')
                var x1 = px - pr,
                    y1 = py - pr,
                    x2 = px + pr,
                    y2 = py + pr;
                var x = dx - px,
                    y = dy - py,
                    l = Math.sqrt(x * x + y * y),
                    rad = r + pr
                if (l < rad) {
                    l = (l - rad) / l * .5

                    if (!isFinite(l)) {
                        l = 0
                    }
                    x *= l
                    y *= l
                    dx -= x
                    dy -= y
                    px += x
                    py += y

                    if (d3.select(this).classed('ended') && d3.select(this).attr('T') == 1) {
                        d3.select(node).attr('cx', Math.max(r, Math.min(w - r, dx)))
                        d3.select(this).attr('cx', Math.max(pr, Math.min(w - pr, px)))

                    } else if (d3.select(node).classed('ended') && d3.select(node).attr('T') == 1) {
                        d3.select(node).attr('cx', Math.max(r, Math.min(w - r, dx)))
                        d3.select(this).attr('cx', Math.max(pr, Math.min(w - pr, px)))
                    } else {
                        d3.select(node).attr('cx', Math.max(r, Math.min(w - r, dx)))
                        d3.select(node).attr('cy', Math.max(r, Math.min(h - r, dy)))
                        d3.select(this).attr('cx', Math.max(pr, Math.min(w - pr, px)))
                        d3.select(this).attr('cy', Math.max(py, Math.min(h - pr, py)))
                    }



                }
                if (!(nx1 > x2 || nx2 < x1 || ny1 > y2 || ny2 < y1) && pointID != nodeID)
                    colliding = true
            })
            return colliding
        }

        function appendToCanvas(flakes) {

            return svg.selectAll()
                .data(flakes)
                .enter()
                .append("svg:circle")
                .classed('new', true)
                .attr('T', 0)
                .attr('r', function(d) {
                    return d.radius
                })
                .attr('cx', function(d) {
                    return d.x
                })
                .attr('cy', function(d) {
                    return d.y
                }).attr('id', function(d) {
                    return d.id
                })
                .transition()
                .ease("linear")
                .duration(1000)
                .attr('T', 1)
                .attr('cx', function(d) {
                    if (+d3.select(this).attr('cy') != h - d.radius) {
                        var mov = (Math.random() * (d.x + 50 - d.x + 50)) + (d.x - 50)
                        d.x = Math.max(d.radius, Math.min(w - d.radius, mov))
                    }
                    return d.x
                })
                .attr('cy', function(d) {
                    var fall = d.y + Math.random() * 200
                    if (fall > h) {
                        fall = h - d.radius
                        d3.select(this)
                            .classed('near-end', true)
                            .classed('moving', false)
                    }
                    return d.y = fall
                })
                .tween("attr", checkCollision())
                .each("end", function(d) {
                    if (!d3.select(this).classed('near-end')) {
                        d3.select(this).classed('moving', true)
                    }
                    d3.select(this).classed('new', false)
                    transition()
                })

        }

        function spawn3RandomFlakes() {
            return d3.range(1).map(function() {
                var r = Math.random() * 15
                return {
                    radius: r,
                    x: Math.random() * w - r,
                    y: -r,
                    id: Math.random()
                }
            })
        }
    </script>
</body>


</html>